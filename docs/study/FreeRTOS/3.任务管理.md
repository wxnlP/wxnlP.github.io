## 3.1 任务的创建与删除

### 3.1.1 任务概念

几个任务的重要概念：

- 栈
- 优先级
- 任务状态
- 任务调度

??? danger  
    任务概念会在后面慢慢学习，现暂不展开说明。

### 3.1.2 创建任务

在FreeRTOS中，一个任务封装为一个函数，而函数地定义形式如下：

```C
void ATaskFunction( void *pvParameters );
```

创建任务地方式分为两种：

- **动态创建任务：** `xTaskCreate`
  - 即通过FreeRTOS的堆管理函数（如：`pvPortMalloc`）分配任务所需的内存空间。

```C
BaseType_t xTaskCreate( 
    					TaskFunction_t pxTaskCode, // 函数指针, 任务函数
                        const char * const pcName, // 任务的名字
                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,一个字(word)四个字节
                        void * const pvParameters, // 调用任务函数时传入的参数
                        UBaseType_t uxPriority,    // 优先级
                        TaskHandle_t * const pxCreatedTask // 任务句柄, 以后使用它来操作这个任务
);
```

- **静态创建任务：** `xTaskCreateStatic`
  - 与动态创建任务不同的在于，静态创建在编译前初始化一个`StaticTask_t`类型的栈（即一个数组）供任务使用。

```C
TaskHandle_t xTaskCreateStatic ( 
                        TaskFunction_t pxTaskCode,   // 函数指针, 任务函数
                        const char * const pcName,   // 任务的名字
                        const uint32_t ulStackDepth, // 栈大小,单位为word,一个字(word)四个字节
                        void * const pvParameters,   // 调用任务函数时传入的参数
                        UBaseType_t uxPriority,      // 优先级
                        StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer
                        StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务
);
```

### 3.1.3 创建任务示例

基于<kbd>第一个多任务程序</kbd>那一节，保留默认的蜂鸣器加LED闪烁任务，修改`RbTask_1`任务，完善动态创建任务流程；同时创建一个简单的OLED每 500 ms自增静态任务。

**创建动态任务**

① 任务函数

```C
/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
void Motor_Task(void *argument)
{
    motor_test();
}

/* USER CODE END Application */
```

② 声明任务函数

```C
/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void *argument);
void Motor_Task(void *argument);
```

③ 定义任务句柄和返回值变量（局部变量）

找到任务句柄类型的定义位置，可以看到`TaskHandle_t`其实是一个void指针，通过官方注释可以知道，任务句柄可以作为一个参数用于`vTaskDelete` 函数删除这个任务。

???danger  
    对于开源的操作系统最大的好处就是开发者可以畅通无阻的阅读注释来学习它，因此学会阅读FreeRTOS的注释也是重要的学习内容。

```C
/**
 * task. h
 *
 * Type by which tasks are referenced.  For example, a call to xTaskCreate
 * returns (via a pointer parameter) an TaskHandle_t variable that can then
 * be used as a parameter to vTaskDelete to delete the task.
 *
 * \defgroup TaskHandle_t TaskHandle_t
 * \ingroup Tasks
 */
typedef void * TaskHandle_t;
```

同样我们可以找到返回值数据类型的定义：

```C
typedef long BaseType_t;
```

由上，我们定义动态任务的任务句柄和返回值：

```C
void MX_FREERTOS_Init(void) {
    /* USER CODE BEGIN Init */
    TaskHandle_t MotorTaskHandle;
    BaseType_t motor_ret;
    /* USER CODE END Init */
	...
}
```

④ 创建动态任务

```C
/* USER CODE BEGIN RTOS_THREADS */
/* add threads, ... */
motor_ret = xTaskCreate(Motor_Task, "MotorTask", 124, NULL, osPriorityNormal, &MotorTaskHandle);
/* USER CODE END RTOS_THREADS */
```

**创建静态任务**

① 任务函数

```C
void OLED_Task(void *argument)
{
    OLED_Test();
}
```

② 声明任务函数

```C
void OLED_Task(void *argument);
```

③ 定义栈和任务结构体变量（全局变量）

`StackType_t`其实就是`uint32_t`类型，我们创建了一个 128 元素的数组，因此该任务的静态分配栈空间为 4x128 字节。

`StaticTask_t`是一个TCB结构体，结构体成员会根据`FreeRTOSConfig.h`的设置相应变化，更多详情可以自行阅读源码。

```C
StackType_t OledStackBuffer[128];
StaticTask_t OledTaskBuffer;
```

④ 定义任务句柄接收返回值（全局变量）

```C
TaskHandle_t OledTaskHandle;
```

⑤ 创建静态任务

```C
OledTaskHandle = xTaskCreateStatic(
	OLED_Task, "OLEDTask", 
    124, 
    NULL, 
    osPriorityNormal,
    OledStackBuffer, 
    &OledTaskBuffer
);
```

### 3.1.4 使用任务参数示例

FreeRTOS中多个任务可以使用同一个函数，然其中亦有差别：

- 栈不同（因此初始化的局部变量是单独的）
- 创建任务时可以传入不同的参数

**以OLED程序为例，同时使用创建任务函数的参数：**

① 定义任务参数结构体

使用`typedef`给结构体重命名，并创建两个数据实体作为后续任务 1 和 2 的函数参数。

```C
/* USER CODE BEGIN FunctionPrototypes */
typedef struct
{
    uint8_t x;
    uint8_t y;
    char str[16];
}Params;
static Params Task1_Params={0, 0,  "Task1:"};
static Params Task2_Params={0, 2,  "Task2:"};
/* USER CODE END FunctionPrototypes */
```

② 任务函数

任务函数内容是计数自增，其中`g_status`全局变量是为了保护`I2C`通信完整当然这不是可靠的，真正的解决方法后面会学习到，这里留一个❓。

???danger  
    如果不加保护措施，实测以后会有失一个任务一个栈的理论。

```C
//定义全局变量
static int g_status = 1;
```

```C
void OLED_Print_Task(void *argument)
{
    Params* p = argument;
    uint32_t cnt=0;
    while (1){
        if(g_status)
        {
            g_status = 0;
            OLED_ShowStr(p->x, p->y, p->str, 16);
            OLED_ShowNum(p->x + 6*8, p->y, cnt, 2, 16);
            cnt++;
            g_status = 1;
        }
        HAL_Delay(500);
    }

}
```

③ 声明任务函数

```C
void OLED_Print_Task(void *argument);
```

④ 创建任务（不使用任务句柄）

传入任务参数地址。

```C
xTaskCreate(OLED_Print_Task, "Task1", 128, &Task1_Params,osPriorityNormal, NULL);
xTaskCreate(OLED_Print_Task, "Task2", 128, &Task2_Params,osPriorityNormal, NULL);
```

### 3.1.5 删除任务示例

**删除任务函数** 

前面我们提到过，任务句柄可以作为`vTaskDelete`参数删除任务。

```c
void vTaskDelete(TaskHandle_t xTaskToDelete );
```

简单的使用逻辑示例：

```C
while (1)
    {
        /* 读取红外遥控器 */
		if (0 == IRReceiver_Read(&dev, &data))
		{		
			if (data == 0xa8) /* play */
			{
                if (xSoundTaskHandle == NULL)
                {
					/* 创建任务 */
                    ret = xTaskCreate(
                    PlayMusic,
                    "SoundTask", 
                    128, 
                    NULL, 
                    osPriorityNormal,
                    &xSoundTaskHandle);
                    }
			}
			
			else if (data == 0xa2) /* power */
			{
				/* 删除播放音乐的任务 */
				if (xSoundTaskHandle != NULL)
				{
					vTaskDelete(xSoundTaskHandle);
					PassiveBuzzer_Control(0); /* 停止蜂鸣器 */
					xSoundTaskHandle = NULL;
				}
			}
		}
    }
```

??? danger "注意"  
    频繁的创建和删除任务在动态分配内存时会导致内存碎片的存在，因此删除任务函数使用并不多，故简单了解使用方法即可。

## 3.2 任务的优先级与状态

