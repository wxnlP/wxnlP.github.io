comments: true

## 5.1 数据传输方法

### 5.1.1 环形缓冲区

全局变量容易出现的问题已经举例过，而环形缓冲区则不宜出现全局变量类似问题。

| 类型       | 数据个数 | 互斥措施 | 阻塞-唤醒 |
| ---------- | -------- | -------- | --------- |
| 全局变量   | 1        | 无       | 无        |
| 环形缓冲区 | 多个     | 无       | 无        |
| 队列       | 多个     | 有       | 有        |

关于环形缓冲区的读写操作及数据是否满：

- 缓冲区空：r位置 == w位置
- 缓冲区满：下一个w位置 == r位置
- 写数据和读数据均从索引 0 开始

```C
/* 环形缓冲区逻辑示例 */
int buf[8];
int r = 0, w = 0;
int next_w = w+1;
if (next_w == 8) { next_w = 0; }
//写数据
if (next_w != r)
{
    buf[w] = value;
    w++;
    if (w == 8) { w = 0; }
}
//读数据
if (r != w)
{
    value = buf[r];
    r++;
    if (r == 8) { r = 0; }
}

```

![image-20250113150205966](5.%E9%98%9F%E5%88%97/image-20250113150205966.png)

### 5.1.2 队列的本质

队列中，数据的读写本质就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制。

-->如果这个队列不传输数据，只调整“数据个数”，它就是信号量(semaphore)。
    
-->如果信号量中，限定“数据个数”最大值为1，它就是互斥量(mutex)。

![image-20250113160424926](5.%E9%98%9F%E5%88%97/image-20250113160424926.png)

在队列中，① 有环形缓冲区，用于存放和读取数据。 ② 两个链表(`SendList`和`ReceiveList`)，用于指定A（或B）写（或读）时唤醒的任务。

以任务B（读数列）为例，分析两种唤醒时序：

**唤醒方式一：**

① TaskB读队列，队列为空，进入阻塞态，设有超时时间。  
???danger "内部变化"  
    创建TaskB进入就绪态，此时TaskB在 **就绪链表** (`pxReadyTasksLists`)；读队列，队列为空，进入阻塞态，此时TaskB在 **队列接收链表** (`ReceiveList`)，同时会入 **延时链表** (`pxDelayedTaskList`)。

② TaskA写队列，同时唤醒TaskB。  
???danger "内部变化"  
    TaskA并非直接唤醒TaskB，而是在 **队列接收链表** (`ReceiveList`)中找到第一个任务，将其放至 **就绪链表** (`pxReadyTasksLists`)，并从 **队列接收链表** (`ReceiveList`)和 **延时链表** (`pxDelayedTaskList`)中将TaskB删除，我们示例中只有一个TaskB，故就是唤醒TaskB。

③ TaskB执行读队列操作（此时未到超时时间）。

![image-20250113162301581](5.%E9%98%9F%E5%88%97/image-20250113162301581.png)

**唤醒方式二：**

① TaskB读队列，队列为空，进入阻塞态，设有超时时间。 

② 一直没有任务写队列，通过Tick中判断达到超时时间，唤醒TaskB。    
???danger "内部变化"  
    Tick中断会从 **队列接收链表** (`ReceiveList`)和 **延时链表** (`pxDelayedTaskList`)中将TaskB删除，放入 **就绪链表** (`pxReadyTasksLists`)。

## 5.2 队列函数

> 本节均不提供函数详细参数解释，仅适当提供源码注释，希望读者掌握通过阅读源码学习函数的使用方法。

### 5.2.1 创建队列

队列的创建有两种方法：

**动态分配内存**

```C
/*
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 */
QueueHandle_t xQueueCreate(
        UBaseType_t uxQueueLength,
        UBaseType_t uxItemSize
);
```

**静态分配内存**

```c
/*
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 */
QueueHandle_t xQueueCreateStatic(
        UBaseType_t uxQueueLength,
        UBaseType_t uxItemSize,
        uint8_t *pucQueueStorageBuffer,
        StaticQueue_t *pxQueueBuffer
);
```

### 5.2.2 复位队列

```C
/*
 * Reset a queue back to its original empty state.  The return value is now
 * obsolete and is always set to pdPASS.‘
 *
 * @param xQueue The handle of the queue being added to the registry.  This
 * is the handle returned by a call to xQueueCreate().
 */

xQueueReset( QueueHandle_t xQueue );
```

### 5.2.3 删除队列

```C
/**
 * queue. h
 * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
 *
 * Delete a queue - freeing all the memory allocated for storing of items
 * placed on the queue.
 *
 * @param xQueue A handle to the queue to be deleted.
 *
 * \defgroup vQueueDelete vQueueDelete
 * \ingroup QueueManagement
 */
void vQueueDelete( QueueHandle_t xQueue )
```

### 5.2.4 写队列

写队列把数据写到队列头部，也可以写到尾部，同时函数分在任务中使用和在中断中使用两个版本。

**在任务中使用：**

```C
/* Post an item on a queue.  The item is queued by copy, not by reference.
 * This function must not be called from an interrupt service routine.
 * See xQueueSendFromISR () for an alternative which may be used in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the
 * queue is full.  The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 */
BaseType_t xQueueSend(
         QueueHandle_t xQueue,
         const void * pvItemToQueue,
         TickType_t xTicksToWait
 );

/* Post an item to the front of a queue. */
BaseType_t xQueueSendToToFront(
        QueueHandle_t	xQueue,
        const void		*pvItemToQueue,
        TickType_t		xTicksToWait
);

/* Post an item to the back of a queue. */
BaseType_t xQueueSendToBack(
        QueueHandle_t	xQueue,
        const void		*pvItemToQueue,
        TickType_t		xTicksToWait
);
```

**在中断中使用：**

```C
/* Post an item to the back of a queue.  It is safe to use this function from
 * within an interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 */
BaseType_t xQueueSendFromISR(
          QueueHandle_t xQueue,
          const void *pvItemToQueue,
          BaseType_t *pxHigherPriorityTaskWoken
);

/* Post an item to the back of a queue. */
BaseType_t xQueueSendToBackFromISR(
        QueueHandle_t xQueue,
        const void *pvItemToQueue,
        BaseType_t *pxHigherPriorityTaskWoken
);

/* Post an item to the front of a queue. */
BaseType_t xQueueSendToFrontFromISR(
         QueueHandle_t xQueue,
         const void *pvItemToQueue,
         BaseType_t *pxHigherPriorityTaskWoken
 );
```

### 5.2.5 读队列

```C
/* Receive an item from a queue.
 * This function must not be used in an interrupt service routine. 
 */
BaseType_t xQueueReceive(
         QueueHandle_t xQueue,
         void *pvBuffer,
         TickType_t xTicksToWait
);

/* Receive an item from a queue.
 * It is safe to use this function from within an interrupt service routine. 
 */
BaseType_t xQueueReceiveFromISR(
         QueueHandle_t	xQueue,
         void	*pvBuffer,
         BaseType_t *pxTaskWoken
);
```

### 5.2.6 查询队列

```C
/* Return the number of messages stored in a queue. */
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );
/* Return the number of free spaces available in a queue. */
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );    
```

## 5.3 队列示例

### 5.3.1 单队列

外部中断写队列，OLED任务读队列并显示。

`freertos.c`文件内容：

```C
/* 定义队列句柄(全局变量) */
QueueHandle_t g_QueueA;
```

```C
/* 存储队列数据的结构体 */
typedef struct{
    int32_t speed;
    int16_t cnt_value;
    char messages[16];
}OLEDData;
```

定义`OLED`任务读队列：

```C
/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
void OLED_Queue_Task(void *argument) {
    /* 创建队列 */
    g_QueueA = xQueueCreate(10, sizeof(OLEDData));
    /* 定义结构体 */
    OLEDData QueueA_Data_Output;
    while (1) {
        /* 读队列A */
        if ( pdPASS == xQueueReceive(g_QueueA, &QueueA_Data_Output, portMAX_DELAY) ) {
            /* 显示队列A数据 */
            OLED_ShowNum(0, 0, QueueA_Data_Output.speed, 1, 16);
            OLED_ShowStr(16, 0, QueueA_Data_Output.messages, 16);
            OLED_ShowNum(0, 2, QueueA_Data_Output.cnt_value, 3, 16);
        }
    }
}
/* USER CODE END Application */
```

```C
xTaskCreate(OLED_Queue_Task, "QueueTask1", 128, NULL, osPriorityNormal, NULL);
```

外部中断写队列：

```C
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    /* 定义变量 */
    extern QueueHandle_t g_QueueA;
    static int16_t cnt;
    /* 定义结构体 */
    OLEDData QueueA_Data_Input;
    if (GPIO_Pin == GPIO_PIN_2) {
        QueueA_Data_Input.speed = cnt % 10;
        QueueA_Data_Input.cnt_value = cnt;
        strcpy(QueueA_Data_Input.messages, "Writed");
        xQueueSendFromISR(g_QueueA, &QueueA_Data_Input, NULL);
        cnt++;
    }
}
```

### 5.3.2 多队列

程序流程如下，两个任务两个队列：

![image-20250115172724004](5.%E9%98%9F%E5%88%97/image-20250115172724004.png)

定义队列句柄变量：

```C
/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
// 定义队列句柄
QueueHandle_t g_QueueA = NULL;
QueueHandle_t g_QueueB = NULL;
/* USER CODE END Variables */C
```

`TIM7`定时中断，写队列A：

```C
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */
    /* 定义变量 */
    extern QueueHandle_t g_QueueA;
    static int16_t cnt;
    /* 定义结构体 */
    EncoderData QueueA_Data_Input;
    if (htim->Instance == TIM7) {
        QueueA_Data_Input.cnt_value = Encoder_Read_CNT(4);
        QueueA_Data_Input.speed = QueueA_Data_Input.cnt_value % 100;
        strcpy(QueueA_Data_Input.messages, "EncoderGet!");
//        OLED_ShowNum(0, 0, QueueA_Data_Input.speed, 4, 16);
//        OLED_ShowStr(40, 0, QueueA_Data_Input.messages, 16);
//        OLED_ShowNum(0, 2, QueueA_Data_Input.cnt_value, 4, 16);
        if (g_QueueA != NULL) {
            xQueueSendFromISR(g_QueueA, &QueueA_Data_Input, NULL);
        }
    }
      /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
```

`OLED`和`Encoder`任务：

```C
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument) {
    /* USER CODE BEGIN StartDefaultTask */
    /* Infinite loop */
    rtMotor_Test();
    /* USER CODE END StartDefaultTask */
}
/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
void OLED_Queue_Task(void *argument) {
    /* 定义结构 */
    OLEDData QueueB_Data_Output;
    while (1) {
        /* 读队列B */
        if (pdTRUE == xQueueReceive(g_QueueB, &QueueB_Data_Output, portMAX_DELAY)) {
            /* 显示队列B数据 */
            OLED_ShowNum(0, 0, QueueB_Data_Output.speed, 4, 16);
            OLED_ShowStr(40, 0, QueueB_Data_Output.messages, 16);
            OLED_ShowNum(0, 2, QueueB_Data_Output.cnt_value, 4, 16);
        }
        vTaskDelay(200);
    }
}

void Encoder_Queue_Task(void *argument) {
    /* 定义结构 */
    EncoderData QueueA_Data_Output;
    OLEDData QueueB_Data_Input;
    while (1) {
        /* 读队列A */
        if (pdTRUE == xQueueReceive(g_QueueA, &QueueA_Data_Output, portMAX_DELAY)) {
            /* 处理队列A数据 */
            QueueB_Data_Input.cnt_value = (int16_t) (QueueA_Data_Output.cnt_value - 1000);
            QueueB_Data_Input.speed = (QueueA_Data_Output.speed) % 10;
            strcpy(QueueB_Data_Input.messages, "SendOLED!");
//            OLED_ShowNum(0, 0, QueueB_Data_Input.speed, 4, 16);
//            OLED_ShowStr(40, 0, QueueB_Data_Input.messages, 16);
//            OLED_ShowNum(0, 2, QueueB_Data_Input.cnt_value, 4, 16);
            /* 发送队列B */
            if (pdTRUE == xQueueSend(g_QueueB, &QueueB_Data_Input, 0)) {
                LED_ON();
            }
        }
        vTaskDelay(200);
    }
}
/* USER CODE END Application */
```

声明函数：

```C
/* USER CODE BEGIN FunctionPrototypes */
void OLED_Queue_Task(void *argument);

void Encoder_Queue_Task(void *argument);

/* USER CODE END FunctionPrototypes */
```

创建队列、任务：

```C
void MX_FREERTOS_Init(void) {
    /* USER CODE BEGIN Init */
    /* 创建队列 */
    g_QueueA = xQueueCreate(10, sizeof(OLEDData));
    g_QueueB = xQueueCreate(10, sizeof(EncoderData));
    /* USER CODE END Init */
    ...
    /* Create the thread(s) */
    /* creation of defaultTask */
    defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
    /* USER CODE BEGIN RTOS_THREADS */
    /* add threads, ... */
    xTaskCreate(OLED_Queue_Task, "QueueTask1", 128, NULL, osPriorityNormal, NULL);
    xTaskCreate(Encoder_Queue_Task, "QueueTask2", 128, NULL, osPriorityNormal, NULL);
    /* USER CODE END RTOS_THREADS */
    ...
}
```

!!!danger  
    记得把默认任务的栈分配小一点，不然内存不够会导致程序卡死。







