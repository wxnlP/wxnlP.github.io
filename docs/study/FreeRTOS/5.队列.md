---
comments: true
---

## 5.1 数据传输方法

### 5.1.1 环形缓冲区

全局变量容易出现的问题已经举例过，而环形缓冲区则不宜出现全局变量类似问题。

| 类型       | 数据个数 | 互斥措施 | 阻塞-唤醒 |
| ---------- | -------- | -------- | --------- |
| 全局变量   | 1        | 无       | 无        |
| 环形缓冲区 | 多个     | 无       | 无        |
| 队列       | 多个     | 有       | 有        |

关于环形缓冲区的读写操作及数据是否满：

- 缓冲区空：r位置 == w位置
- 缓冲区满：下一个w位置 == r位置
- 写数据和读数据均从索引 0 开始

```C
/* 环形缓冲区逻辑示例 */
int buf[8];
int r = 0, w = 0;
int next_w = w+1;
if (next_w == 8) { next_w = 0; }
//写数据
if (next_w != r)
{
    buf[w] = value;
    w++;
    if (w == 8) { w = 0; }
}
//读数据
if (r != w)
{
    value = buf[r];
    r++;
    if (r == 8) { r = 0; }
}

```

![image-20250113150205966](5.%E9%98%9F%E5%88%97/image-20250113150205966.png)

### 5.1.2 队列的本质

队列中，数据的读写本质就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制。

-->如果这个队列不传输数据，只调整“数据个数”，它就是信号量(semaphore)。
    
-->如果信号量中，限定“数据个数”最大值为1，它就是互斥量(mutex)。

![image-20250113160424926](5.%E9%98%9F%E5%88%97/image-20250113160424926.png)

在队列中，① 有环形缓冲区，用于存放和读取数据。 ② 两个链表(`SendList`和`ReceiveList`)，用于指定A（或B）写（或读）时唤醒的任务。

以任务B（读数列）为例，分析两种唤醒时序：

**唤醒方式一：**

① TaskB读队列，队列为空，进入阻塞态，设有超时时间。  
???danger "内部变化"  
    创建TaskB进入就绪态，此时TaskB在 **就绪链表** (`pxReadyTasksLists`)；读队列，队列为空，进入阻塞态，此时TaskB在 **队列接收链表** (`ReceiveList`)，同时会入 **延时链表** (`pxDelayedTaskList`)。

② TaskA写队列，同时唤醒TaskB。  
???danger "内部变化"  
    TaskA并非直接唤醒TaskB，而是在 **队列接收链表** (`ReceiveList`)中找到第一个任务，将其放至 **就绪链表** (`pxReadyTasksLists`)，并从 **队列接收链表** (`ReceiveList`)和 **延时链表** (`pxDelayedTaskList`)中将TaskB删除，我们示例中只有一个TaskB，故就是唤醒TaskB。

③ TaskB执行读队列操作（此时未到超时时间）。

![image-20250113162301581](5.%E9%98%9F%E5%88%97/image-20250113162301581.png)

**唤醒方式二：**

① TaskB读队列，队列为空，进入阻塞态，设有超时时间。 

② 一直没有任务写队列，通过Tick中判断达到超时时间，唤醒TaskB。    
???danger "内部变化"  
    Tick中断会从 **队列接收链表** (`ReceiveList`)和 **延时链表** (`pxDelayedTaskList`)中将TaskB删除，放入 **就绪链表** (`pxReadyTasksLists`)。

## 5.2 队列函数

> 本节均不提供函数详细参数解释，仅适当提供源码注释，希望读者掌握通过阅读源码学习函数的使用方法。

### 5.2.1 创建队列

队列的创建有两种方法：

**动态分配内存**

```C
/*
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 */
QueueHandle_t xQueueCreate(
        UBaseType_t uxQueueLength,
        UBaseType_t uxItemSize
);
```

**静态分配内存**

```c
/*
 * Creates a new queue instance, and returns a handle by which the new queue
 * can be referenced.
 */
QueueHandle_t xQueueCreateStatic(
        UBaseType_t uxQueueLength,
        UBaseType_t uxItemSize,
        uint8_t *pucQueueStorageBuffer,
        StaticQueue_t *pxQueueBuffer
);
```

### 5.2.2 复位队列

```C
/*
 * Reset a queue back to its original empty state.  The return value is now
 * obsolete and is always set to pdPASS.‘
 *
 * @param xQueue The handle of the queue being added to the registry.  This
 * is the handle returned by a call to xQueueCreate().
 */

xQueueReset( QueueHandle_t xQueue );
```

### 5.2.3 删除队列

```C
/**
 * queue. h
 * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
 *
 * Delete a queue - freeing all the memory allocated for storing of items
 * placed on the queue.
 *
 * @param xQueue A handle to the queue to be deleted.
 *
 * \defgroup vQueueDelete vQueueDelete
 * \ingroup QueueManagement
 */
void vQueueDelete( QueueHandle_t xQueue )
```

### 5.2.4 写队列

写队列把数据写到队列头部，也可以写到尾部，同时函数分在任务中使用和在中断中使用两个版本。

**在任务中使用：**

```C
/* Post an item on a queue.  The item is queued by copy, not by reference.
 * This function must not be called from an interrupt service routine.
 * See xQueueSendFromISR () for an alternative which may be used in an ISR.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xTicksToWait The maximum amount of time the task should block
 * waiting for space to become available on the queue, should it already
 * be full.  The call will return immediately if this is set to 0 and the
 * queue is full.  The time is defined in tick periods so the constant
 * portTICK_PERIOD_MS should be used to convert to real time if this is required.
 *
 * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
 */
BaseType_t xQueueSend(
         QueueHandle_t xQueue,
         const void * pvItemToQueue,
         TickType_t xTicksToWait
 );

/* Post an item to the front of a queue. */
BaseType_t xQueueSendToToFront(
        QueueHandle_t	xQueue,
        const void		*pvItemToQueue,
        TickType_t		xTicksToWait
);

/* Post an item to the back of a queue. */
BaseType_t xQueueSendToBack(
        QueueHandle_t	xQueue,
        const void		*pvItemToQueue,
        TickType_t		xTicksToWait
);
```

**在中断中使用：**

```C
/* Post an item to the back of a queue.  It is safe to use this function from
 * within an interrupt service routine.
 *
 * Items are queued by copy not reference so it is preferable to only
 * queue small items, especially when called from an ISR.  In most cases
 * it would be preferable to store a pointer to the item being queued.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
 * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
 * to unblock, and the unblocked task has a priority higher than the currently
 * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
 * a context switch should be requested before the interrupt is exited.
 *
 * @return pdTRUE if the data was successfully sent to the queue, otherwise
 * errQUEUE_FULL.
 */
BaseType_t xQueueSendFromISR(
          QueueHandle_t xQueue,
          const void *pvItemToQueue,
          BaseType_t *pxHigherPriorityTaskWoken
);

/* Post an item to the back of a queue. */
BaseType_t xQueueSendToBackFromISR(
        QueueHandle_t xQueue,
        const void *pvItemToQueue,
        BaseType_t *pxHigherPriorityTaskWoken
);

/* Post an item to the front of a queue. */
BaseType_t xQueueSendToFrontFromISR(
         QueueHandle_t xQueue,
         const void *pvItemToQueue,
         BaseType_t *pxHigherPriorityTaskWoken
 );
```

### 5.2.5 读队列

```C
/* Receive an item from a queue.
 * This function must not be used in an interrupt service routine. 
 */
BaseType_t xQueueReceive(
         QueueHandle_t xQueue,
         void *pvBuffer,
         TickType_t xTicksToWait
);

/* Receive an item from a queue.
 * It is safe to use this function from within an interrupt service routine. 
 */
BaseType_t xQueueReceiveFromISR(
         QueueHandle_t	xQueue,
         void	*pvBuffer,
         BaseType_t *pxTaskWoken
);
```

### 5.2.6 查询队列

```C
/* Return the number of messages stored in a queue. */
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );
/* Return the number of free spaces available in a queue. */
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );    
```