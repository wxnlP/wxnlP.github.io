## 3.2 编译构建系统

> 基于轻量系统

### 3.2.1 编译构建系统简介

1. OpenHarmony基于<kbd>gn</kbd>和<kbd>ninja</kbd>，以支持组件化开发为目标。
2. 支持独立构建<kbd>组件</kbd>、<kbd>开发板</kbd>、<kbd>组件拼接的产品</kbd>。

???note  
    关于组件这个名称，我查看官网为部件，都是指component，系统最小功能单元。

编译构建系统用到的相关基础概念

| 名称       | 概念                                                  |
| ---------- | ----------------------------------------------------- |
| **子系统** | 子系统由一个或多个组件构成。                          |
| **组件**   | 组件是一个可复用、可配置、可裁剪的系统最小功能单元。  |
| **ninja**  | ninja是一个专注速度的小型的编译构建系统。             |
| **gn**     | gn全称为 "generate ninja"，是一个现代化编译构建工具。 |
| **hb**     | hb是OpenHarmony的命令行工具，用于执行编译命令。       |

???note  
    联系一下常见的工具会更好理解，比如当我们使用STM32的Cmake开发方式时，我们的编译构建系统使用的就是Camke和ninja，此时Camke就是与gn一样的作用。

关于系统、子系统、组件的关系如下图，其中子系统和组件支持 **裁剪** 。

![image-20241229142621148](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241229142621148.png)

`build/lite`是轻量级设备（如 IoT 设备）编译构建系统的核心部分，目录主要内容如下：

```
build/lite            
├── components        # 组件描述文件
├── config		  	  # 编译配置文件
|   ├── component     # 组件相关模板定义
|   ├── kernel        # 内核的编译配置参数
|   └── subsystem     # 子系统的编译配置模板
├── figures           # readme的图片
├── hb                # hb的pip安装包源码
├── make_rootfs       # 文件系统镜像制作脚本
├── ndk               # Native API相关编译脚本与配置参数
├── testfwk           # 测试编译框架
└── toolchain         # 编译工具链配置
```

在轻量系统中，一个组件不能单独编译，必须加入一个产品或开发板方案。关于前面用到的编译指令：

- `hb set`，用于选择OpenHarmony的源码目录和要编译的目标保存至相应的配置文件中。

- `hb build`，经历一个较为复杂的过程
  1. 读取编译配置。根据产品选择的开发板，读取开发板的`config.gni`文件。
  2. 调用gn。生成从产品解决方案的`out`目录和`ninja`文件。
  3. 调用ninja。也就是调用“`ninja -C out/board/product`”命令启动编译。
  4. 系统镜像文件打包。就是将组件编译产物进行打包，设置文件的属性和权限，制作文件系统的镜像文件。

> 关于系统镜像文件打包简单理解就是生成`.bin`二进制烧录文件。

### 3.2.2 编译构建系统的配置规则

???danger  
    这里很重要也很难，若此部分不理解，建议购买书籍阅读。

- **源码的命名规则**
  1. 一个组件一个单独的文件夹。
  2. 组件源码分为三层，最外层为<kbd>领域</kbd>，也称为子系统集，内层依次为<kbd>子系统</kbd>和<kbd>组件</kbd>

- **源码目录树的构建规则**

  1. 组件的目录结构应如下：

  ```
  component
  ├── interfaces       # 接口
  |	├── innerkits    # 系统内接口，供组件开发者使用
  |	└── kits         # 应用接口，供应用开发者使用
  ├── frameworks       # framework的实现
  ├── services         # service的实现
  └── BUILD.gn         # 组件的编译脚本
  ```

  2. 以IOT外围设备控制组件为例

  IOT外围设备控制 **组件** 从属于IOT专用硬件服务 **子系统** ，IOT专用硬件服务子系统又从属于硬件服务 **子系统集** 。

  - 硬件服务子系统集的位置在源码的`base`目录。
  - IOT专用硬件服务子系统的位置在`base\iot_hardware`目录。
  - IOT外围设备控制组件位置就在`base\iot_hardware\peripheral`目录。

  ![image-20241229225609808](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241229225609808.png)

 **由此领域即子系统集、子系统、组件的目录结构就很明了了。**进一步剖析目录，在`interfaces`下有`kits`目录提供了应用接口，供应用开发者使用；注意`BUILD.gn`位于组件`peripheral`的根目录下，即为这个组件的编译脚本。

- **组件的定义**

  1. 新建好一个组件后，我们需要将其定义到OpenHarmony系统中。而组件定义的位置就在`build\lite\components`目录下的`.json`文件。

  ![image-20241229225836412](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241229225836412.png)

  2. 组件必须注册到 **子系统** 中。然后，需要把组件的基本信息告诉子系统就完成了组件的定义。

  以下就是`iot_hardware.json`文件的全部定义：

  ```json
  {
    "components": [                                               // 全部组件
      {                                                           // 单个组件定义
        "component": "iot_controller",                            // 组件名称
        "description": "Iot peripheral controller.",              // 组件的功能描述
        "optional": "false",                                      // 组件是否为最小系统必选
        "dirs": [ "base/iot_hardware/peripheral"],                // 组件源码目录
        "targets": ["//base/iot_hardware/peripheral:iothardware"],// 组件编译目标
        "output": [],                                             // 组件编译输出
        "rom": "",                                                // 组件的ROM容量
        "ram": "",                                                // 组件的RAM容量
        "adapted_kernel": ["liteos_m"],                           // 组件已适配的内核 
        "features": [],                                           // 组件可配置的特性
        "deps": {                                                 // 组件依赖  
          "components": [],                                       // 组件依赖的其他组件
          "third_party": []                                       // 组件依赖的第三方开源软件
        }
      }
    ]
  }
  
  ```

- **组件的编译目标** （编译入口）
  1. 编译入口其实就是组件的`targets`参数，格式约束如此`"targets":["路径:目标名称"]`。其中 **路径** 以绝对路径表示，`//` 开头，以源码根目录开始， **目标名称** 由路径下的`BUILD.gn`文件定义。
  2. OpenHarmony的编译构建系统会通过这个路径找到目标的`BUILD.gn`文件，然后根据目标名称，按照这部分的要求进行编译。

- **组件的编译脚本**

  > 以下是几种基础语法，更多可参考[OpenHarmony官方关于gn介绍](https://docs.openharmony.cn/pages/v4.1/zh-cn/device-dev/subsystems/subsys-build-gn-coding-style-and-best-practice.md)或谷歌官网。

  - 编译结果类型
    - `executable`，生成可执行文件，`.bin`文件。
    - `shared_library`，生成动态链接库，`.so`文件。
    - `static_library`，生成静态链接库，`.a`文件。
    - `source_set`，生成中间目标，仅用于编译源文件，不生成最终的二进制文件或库。
    - `group`，聚合多个目标，无直接产物。
  - 目标：编译 **目标名称** ，与`targets`参数的目标名称一致，官方建议与组件名称一致。
  - sources：需要编译的源文件列表，即由逗号隔开的多个`.c`文件。
  - include_dirs：头文件的路径列表，即逗号隔开的头文件所在位置，绝对路径或相对路径。

  `BUILD.gn`模板

  ```
  类型("目标名称"){
  	sources = [
  		".c",
  		".c",
  		......
  	]
  	include_dirs = [
  		"路径",
  		"路径",
  		......
  	]
  }
  ```

  IOT外围设备控制组件为例，目标如下`"targets": ["//base/iot_hardware/peripheral:iothardware"]`，找到一个名为 `iothardware` 的目标组。

  ![image-20241229235814264](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241229235814264.png)

  注意`$ohos_board_adapter_dir`代指的目录为`device\hisilicon\hispark_pegasus\hi3861_adapter`，则在`device\hisilicon\hispark_pegasus\hi3861_adapter\hals\iot_hardware\wifiiot_lite:hal_iothardware`下找到另一个`BUILD.gn`文件。编译类型为静态库，会编译`sources`下的`.c`文件，`include_dirs`为保护的头文件。

  ![image-20241230000417092](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241230000417092.png)

  再举一个例子`"targets": ["//utils/native/lite/kv_store"]`，找到`BUILG.gn`文件。

  ![image-20241230001308441](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241230001308441.png)

  这个脚本通过`lite_component`的`feature`方式指向`utils\native\lite\kv_store\src`目录下的`BUILG.gn`文件

  ![image-20241230001509865](3.OH%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20241230001509865.png)