---
comments: true
---

## 2.1 宏

### 2.1.1 宏函数

测试程序：

```C
include <stdio.h>

#define FUNC_1(a, b) a*b
#define FUNC_2(a, b) (a*b)
#define FUNC_3(a, b) a = a * b; a++
#define FUNC_4(a, b) { a = a * b; a++; }
#define FUNC_5(a, b) do { a = a * b; a++; } while(0)

int main(void)
{
	int a = 10;
	// 1.期望值为100
	a = FUNC_1(9+1, 10);
	printf("[INFO] %d\r\n", a);

	// 2.期望值100
	a = 10;
	a = FUNC_2(a, 10);
	printf("[INFO] %d\r\n", a);

	// 3.期望值101
	a = 10;
	FUNC_3(a, 10);
	printf("[INFO] %d\r\n", a);

	// 4.期望值10
	a = 10;
	if (0)
		FUNC_3(a, 10);
	printf("[INFO] %d\r\n", a);

	// 5.期望值111（编译会出错，故注释）
	/*if (0) 
		FUNC_4(a, 10);
	else
		FUNC_4(a, 11);
	printf("[INFO] %d\r\n", a);
	*/

	// 6.期望值111
	a = 10;
    if (0) {	
        FUNC_4(a, 10);
	}
    else {
        FUNC_4(a, 11);
	}
    printf("[INFO] %d\r\n", a);

	// 7.期望值111
	a = 10;
	if (0)
        FUNC_5(a, 10);
    else
        FUNC_5(a, 11);
    printf("[INFO] %d\r\n", a);

	return 0;
}
```

输出结果：

```
[INFO] 19
[INFO] 100
[INFO] 101
[INFO] 11
[INFO] 111
[INFO] 111
```

**问题解析**

> 需要同代码注释的序号

① 期望值为100，输出值为19

原因在于，宏仅是文本的展开，查看预编译文件，如下图。

![image-20250522175237176](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250522175237176.png)

② 期望值为100，输出值为100

√

③ 期望值为101，输出值为101

√

④ 期望值为10，输出值为11

程序未套大括号，导致`if`仅阻碍了第一句宏代码，后一句被执行。

![image-20250522175432681](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250522175432681.png)

⑤ 期望值为111，编译出错

`FUNC_4`可以解决`FUNC_3`在④中的问题，但当`if`和`else`一起使用时会出现新的问题。原因在于`FUNC_4`会使得`if`提前结束，预编译程序，如下图：

![image-20250522175848341](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250522175848341.png)

⑥和⑦是两种可以解决⑤的问题的方法。

但是，⑥依赖外层 `{}` 保证语法正确性，通过预编译文件可以发现， **⑦更符合语法标准** ，也是一种常见的写法。

![image-20250522180530917](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250522180530917.png)

### 2.1.2 调试宏

调试宏用于结合`printf`函数实现规范性的日志打印，常见的操作符和内置宏如下：

- `#`：字符串化操作符，宏参数转换为字符串常量。
- `##`：标记连接符，将两个宏参数连接成一个新的标识符。
- `__FUNCTION__`：调用宏的函数名，是一个字符串。
- `__LINE__`：调用宏的所在行号，是一个数字。
- `__FILE__`：调用宏的所在文件名，是一个字符串。

**字符化**

> 这个功能在调试、日志记录等场景中非常有用，可以将变量名或值直接转换为字符串形式。

测试程序：

```c
#include <stdio.h>

#define LOG_INFO(info) printf("[%s] %s\r\n", #info, info)

int main(void)
{
    char INFO[] = "hello world"; 
    LOG_INFO(INFO);
    return 0;
}
```

输出结果：

```
[INFO] hello world
```

**连接符**

> 这种特性常用于生成代码中的变量名、函数名、枚举值等场景，尤其在需要泛型编程或代码复用时非常有用。

测试程序：

```c
#include <stdio.h>

#define LOG_INFO(info) printf("[INFO] %s is %d.\r\n", #info, info)

/* 1.生存规则变量，并通过宏调用 */
#define VAR_GENERATOR(num) int var_##num
#define VAR(num) var_##num

/* 2.泛型函数生成 */
#define ATTRIBUTE_FUNCTION(type, name) type get_##name(void) { return name; }

/* 3.枚举与字符串映射 */
#define COLORS(name) Color_##name

typedef enum {
	COLORS(Red),
	COLORS(Green),
	COLORS(Blue),
} Colors;


int main(void)
{
	// 1.生存规则变量，并通过宏调用
	VAR_GENERATOR(1) = 10;
	VAR_GENERATOR(2) = 100;	
	LOG_INFO(VAR(1));
	LOG_INFO(VAR(2));
	LOG_INFO(var_1);
	LOG_INFO(var_2);
	// 2.泛型函数生成
	int age = 18;
	ATTRIBUTE_FUNCTION(int, age);
	LOG_INFO(get_age());
	// 3.枚举与字符串映射
	LOG_INFO(Color_Red);
	LOG_INFO(Color_Green);
	LOG_INFO(Color_Blue);

	return 0;
}
```

输出结果：

```
[INFO] VAR(1) is 10.
[INFO] VAR(2) is 100.
[INFO] var_1 is 10.
[INFO] var_2 is 100.
[INFO] get_age() is 18.
[INFO] Color_Red is 0.
[INFO] Color_Green is 1.
[INFO] Color_Blue is 2.
```

**内置宏**

修改文件中的日志宏：

```c
#define LOG_INFO(info) printf("[INFO] [%s : %s : %d]--> %s is %d.\r\n",\
                                __FILE__,\
                                __FUNCTION__,\
                                __LINE__,\
                                #info, info)
```

修改后的输出结果：

```
[INFO] [main.c : main : 31]--> VAR(1) is 10.
[INFO] [main.c : main : 32]--> VAR(2) is 100.
[INFO] [main.c : main : 33]--> var_1 is 10.
[INFO] [main.c : main : 34]--> var_2 is 100.
[INFO] [main.c : main : 38]--> get_age() is 18.
[INFO] [main.c : main : 40]--> Color_Red is 0.
[INFO] [main.c : main : 41]--> Color_Green is 1.
[INFO] [main.c : main : 42]--> Color_Blue is 2.
```

进一步修改文件中的日志宏，修改为类似`printf`函数：

```C
#include <stdio.h>

#define LOG_INFO(info, ...) printf("[INFO] [%s : %s : %d]--> "info"\r\n",\
								__FILE__,\
								__FUNCTION__,\
								__LINE__,\
								##__VA_ARGS__)

/* 1.生存规则变量，并通过宏调用 */
#define VAR_GENERATOR(num) int var_##num
#define VAR(num) var_##num

/* 2.泛型函数生成 */
#define ATTRIBUTE_FUNCTION(type, name) type get_##name(void) { return name; }

/* 3.枚举与字符串映射 */
#define COLORS(name) Color_##name

typedef enum {
	COLORS(Red),
	COLORS(Green),
	COLORS(Blue),
} Colors;


int main(void)
{
	// 1.生存规则变量，并通过宏调用
	VAR_GENERATOR(1) = 10;
	VAR_GENERATOR(2) = 100;	
	LOG_INFO("%d", VAR(1));
	LOG_INFO("%d", VAR(2));
	LOG_INFO("%d", var_1);
	LOG_INFO("%d", var_2);
	// 2.泛型函数生成
	int age = 18;
	ATTRIBUTE_FUNCTION(int, age);
	LOG_INFO("%d", get_age());
	// 3.枚举与字符串映射
	LOG_INFO("%d", Color_Red);
	LOG_INFO("%d", Color_Green);
	LOG_INFO("%d", Color_Blue);

	return 0;
}
```

修改后的输出结果：

```
[INFO] [main.c : main : 31]--> 10
[INFO] [main.c : main : 32]--> 100
[INFO] [main.c : main : 33]--> 10
[INFO] [main.c : main : 34]--> 100
[INFO] [main.c : main : 38]--> 18
[INFO] [main.c : main : 40]--> 0
[INFO] [main.c : main : 41]--> 1
[INFO] [main.c : main : 42]--> 2
```

