---
comments: true
---

## 1.1 Vim编辑器

Vim是从Vi发展出来的编辑器，具有代码补全、查找、快速跳转等功能。其中Vim共分为普通模式、输入模式、命令行模式，切换模式命令如下图。

![1](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/G7uRbLJ2Hosxqxxf28bcq3EfnEh.png)

### 1.1.1 普通模式

使用`vim <doc_name>`命令启动Vim后，默认进入普通模式。此模式下，不能直接输入文本内容，主要进行 **文本替换** 、 **文本查找** 、 **删除文字**  、 **复制粘贴** 等操作。

- 【切换模式】
  - `i`：在光标当前位置输入。
  - `a`：在光标后一个位置输入。
  - `o`：在光标所在行的下一行输入。
  - `:`：进入命令行模式。

> 进入命令行模式直接跟具体命令。
>

- 【光标移动】
  - `h`：光标向左移动一个字符。
  - `j`：光标向下移动一行。
  - `k`：光标向上移动一行。
  - `l`：光标向右移动一个字符。

> 实际上这四个键并不好用，我们可以使用上下左右四个键更直观一些。
>

- 【翻页】
  - `Ctrl + f`：向下翻页。
  - `Ctrl + b`：向上翻页。

> 翻页多用于浏览文本。
>

- 【删除】
  - `x`：删除光标所在位置的字符。
  - `dd`：删除光标所在的整行内容。
  - `dw`：删除从光标位置开始到单词末尾的字符。

> 键盘的Delete键与x键功能一致。
>

- 【撤销】
  - `u`：撤销上一次的操作。
  - `Ctrl + r`：重做上一次撤销的操作。

- 【复制粘贴】
  - `yy`：复制当前行。
  - `dd`：剪切当前行。
  - `p(小写)`：粘贴内容到光标的下方。
  - `P(大写)`：粘贴内容到光标的上方。

> 在`yy`前加上数字，可以复制多行，如`3yy`复制光标所在行开始的 3 行内容。`dd`既是删除，也可以实现剪切。
>

- 【查找】
  - `/`：查找字符串。
  - `n(小写)`：继续查找下一个匹配项。
  - `N(大写)`：继续查找上一个匹配项。

> 注意区分大小写，替换在命令行模式进行。
>

### 1.1.2 输入模式

在普通模式下，按下`i/a/o`键进入输入模式。此模式下，可以直接 **编辑文本内容** ，按下`Esc`键就能回到普通模式。

> 该模式无特殊命令，主要进行文本修改。
>

### 1.1.3 命令行模式

在普通模式下，按下`:`键进入命令行模式。此模式下，可以执行保存内容、退出Vim等操作，按下`Esc`键就能回到普通模式。

- 【保存与退出】
  - `:w`：保存文件。
  - `:q`：退出Vim。
  - `:q!`：强制退出 Vim，即使文件修改没有保存也会退出（慎用）。
  - `:wq`：保存文件，然后退出Vim。

- 【替换】
  - `:s/旧字符串/新字符串/g`：可以在当前行替换所有的旧字符串为新字符串。
  - `:%s/旧字符串/新字符串/g`：整个文件范围内替换。

> `:`是从普通模式进入命令行模式，后面直接跟命令，因此替换均是在命令行模式下进行的。

### 1.1.4 Vim使用练习

新建文件夹和 C 文件：

```shell
# 新建文件夹
mkdir c_proficient_road
cd c_proficient_road
# 新建C文件
touch vim_cmd.c
# 打开C文件
vim vim_cmd.c
```

使用 Vim 命令写一个基础程序，并保存，如下图。

![image-20250502145605785](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502145605785.png)

## 1.2 GCC

GCC（GNU Compiler Collection）是 [GNU](https://so.csdn.net/so/search?q=GNU&spm=1001.2101.3001.7020) 开源项目的一套开源编译器工具集，最初仅编译 C 语言，但现在的 GCC 支持编译 C++ 、Java、GO等多种编程语言，Linux内核就是采用 GCC 搭建的编译构建系统。

> **gcc** （GUN C Compiler）是GCC中的 c 编译器，而 **g++** （GUN C++ Compiler）是 GCC 中的 c++ 编译器。
>
> gcc 和 g++ 两者都可以编译 c 和 cpp 文件，但存在差异。gcc 在编译 cpp 时语法按照 c 来编译但默认不能链接到 c++ 的库（ gcc 默认链接 c 库， g++ 默认链接 c++ 库）。g++ 编译 <kbd>.c</kbd> 和 <kbd>.cpp</kbd> 文件都统一按 cpp 的语法规则来编译。所以一般编译 c 用 gcc ，编译 c++ 用 g++ 。

### 1.2.1 GCC安装

GCC 是 Linux 默认的 C/C++ 编译器，大部分 Linux 发行版都默认安装。若是需要手动安装，在终端执行以下命令安装：

```shell
# 更新软件包列表
sudo apt update

# 安装 GCC 及基础开发工具（包括 make、g++、libc-dev 等）
sudo apt install build-essential
```

验证 gcc 和 g++ 是否安装成功：

```shell
gcc -v
g++ -v
```

单独安装特定的 GCC 组件，如 g++、cmake等。

```shell
# 安装g++
sudo apt install g++
# 安装gdb
sudo apt install gdb
```

### 1.2.2 gcc编译器

gcc （GUN C Compiler）是 GCC 中的 c 编译器。

gcc 常用参数如下表：

- 【编译】
  - `-E`：仅执行预处理（生成后缀为 `.i` 的预处理文件）
  - `-S`：执行预处理和编译（生成后缀为 `.s` 的汇编文件）
  - `-c`：执行预处理、编译和汇编（生成后缀为 `.o` 的二进制文件）
  - `-o`：链接库文件，生成可执行文件
  - `-g`：嵌入调试信息，方便gdb调试
  - `-v`：查看gcc编译器的版本，显示gcc执行时的详细过程

- 【代码优化】

  - `-O0`：禁用所有优化，保留完整调试信息
  - `-O1`：平衡代码大小和执行速度
  - `-O2`：提升执行速度，适度增加代码体积
  - `-O3`：极致性能，显著增加代码体积
  - `-Os`：最小化代码体积
  - `-Ofast`：极致性能，忽略严格标准合规性
  - `-finline-functions`：将小函数直接嵌入调用处，减少函数调用开销
  - `-funroll-loops`：循环展开，减少循环控制开销，提升指令级并行性

- 【警告控制】

  - `-Wall`：打开编译告警
  - `-Werror`：将所有的警告当成错误进行处理，在所有产生警告的地方停止编译

- 【库文件链接】

  - `-static`：链接静态库

  - `-share`：链接动态库

  - `-l`：指定要链接的 **库文件名称**

    - > `-l` 参数紧接着就是库名(无空格)，例如：数学库为<kbd>libm.so</kbd>，参数就是`-lm`，即去掉`lib`和`.so`。放在 `/lib` 、`/usr/lib`和`/usr/local/lib` 里的库直接用 -l 参数就能链接，其他位置的库文件需要指定目录路径。

  - `-L`：指定要链接的 **库文件路径**

    - > `-L`参数紧接着就是目录(无空格)，除 `/lib` 、`/usr/lib`和`/usr/local/lib`以外，其他目录的库，需要使用`-L`参数指定目录路径，`-L.`即当前目录。

  - `-I`：指定 **头文件目录**

    - > `-I`参数紧接着就是目录(无空格)，`/usr/include`目录一般是不用指定，其他目录则需要指定，可以用相对路径。

**基础编译**

编译命令格式：

```shell
# <input_name>是要编译的C文件名称
# <output_name>是生成的可执行文件的名称（默认名称为a.out/a.exe）
gcc <input_name> -o <output_name> 
```

编译命令示例：

```shell
# 编译vim_cmd.c
gcc vim_cmd.c -o vim_cmd
# 查看文件生成
ls
```

运行可执行文件：

```shell
./vim_cmd
```

![image-20250502152712701](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502152712701.png)



### 1.2.3 gdb调试器

GDB（GNU Project Debugger）是 GNU 项目开发的开源调试工具，支持 **C/C++** 、 **Fortran** 、 **Go**  等多种编程语言，主要用于检查程序运行状态、定位崩溃原因及分析逻辑错误。其核心功能包括：

- Start your program, specifying anything that might affect its behavior.（指定一些参数）
- Make your program stop on specified conditions.（断点）
- Examine what has happened, when your program has stopped.（分析crash现场）
- Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.（直接修改程序，看结果）

常用的 gdb 命令如下表，可以使用简写。

| 命令                | 缩写  | 功能                                 | 示例           |
| ------------------- | ----- | ------------------------------------ | -------------- |
| `run`               | `r`   | 启动程序                             | `run`          |
| `break <行号>`      | `b`   | 设置断点                             | `b 20`         |
| `next`              | `n`   | 单步执行（不进入函数）               | `n`            |
| `step`              | `s`   | 单步执行（进入函数）                 | `s`            |
| `print <表达式>`    | `p`   | 打印变量值或表达式结果               | `p x`          |
| `backtrace`         | `bt`  | 查看函数调用堆栈                     | `bt`           |
| `info locals`       |       | 显示当前函数的局部变量               | `info locals`  |
| `info breakpoints`  | `i b` | 列出所有断点                         | `i b`          |
| `delete <断点编号>` | `d`   | 删除断点                             | `d 2`          |
| `watch <变量>`      |       | 监视变量变化时暂停                   | `watch x`      |
| `quit`              | `q`   | 退出 GDB                             | `q`            |
| `list <行号>`       |       | 展示指定行号上下各 5 行程序          | `list 8`       |
| `diaplay <变量>`    |       | 监控变量变化，每次停下来都显示它的值 | `dispaly a`    |
| `undiaplay <变量>`  |       | 取消监控变量变化                     | `undispaly a`  |
| `set var <表达式>`  |       | 修改变量的值                         | `set var a=15` |
| `until <行号>`      |       | ⭐进行指定位置跳转，执行完区间代码    | `until 10`     |
| `finish`            |       | ⭐在一个函数内部，执行到当前函数返回  | `finish`       |
| `continue`          | `c`   | ⭐继续执行到下一个断点                | `c`            |

**修改程序**

> 在命令行模式输入命令`set nu`可以显示行数。

![image-20250502162041546](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502162041546.png)

**基础调试**

① 编译程序生成调试信息

使用 gdb 调试程序，需要在 gcc 编译时加上 `-g` 参数生成调试信息。

```shell
gcc vim_cmd.c -o vim_cmd -g
```

② 启动 gdb

以`vim_cmd.c`为例，启动 gdb 调试。

```shell
# vim_cmd为可执行文件，-q用于取消gdb的一些版本信息输出
gdb ./vim_cmd -q
```

启动 gdb 以后，会进入 gdb 的命令行环境，使用 gdb 的命令即可进行对应的调试工作，界面如下图所示：

![image-20250502162656352](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502162656352.png)

③ 查看程序

查看第 8 行左右的程序。

```shell
list 8
```

![image-20250502164202113](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502164202113.png)

④ 断点

在第 8 行打一个断点。

```shell
bread 8
```

![image-20250502164236053](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502164236053.png)

⑤ 运行

```shell
run
```

![image-20250502164342522](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502164342522.png)

⑥ 单步执行

```shell
next 
```

查看第 8 行运行前后，变量`a`的变化：

![image-20250502164530789](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502164530789.png)

⑦ 查看变量信息

基于变量查看信息：

```shell
# 查看地址
print &a
# 查看值(10进制)
print a
# 或 print/d a
# 查看值(16进制)
print/x a
# 查看值(2进制)
print/t a
```

![image-20250502171456909](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502171456909.png)

基于地址查看信息：

`examine`命令用于检查内存地址中的内容，缩写为`x`，支持多种显示格式和单位大小。

| **参数** | **功能**                                                     |
| :------- | :----------------------------------------------------------- |
| **数量** | 要显示的内存单元数量（默认为1）。                            |
| **格式** | `x`（十六进制）、`d`（十进制）、`u`（无符号十进制）、`t`（二进制）等。 |
| **单位** | `b`（字节）、`h`（半字，2字节）、`w`（字，4字节）、`g`（双字，8字节）。 |

具体格式如下：

```shell
x/[数量][格式][单位] <地址>
```

为了更直观的展示`examine`命令，修改程序，添加一个数组：

![image-20250502172305301](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502172305301.png)

重新编译并启动调试。

![image-20250502172352776](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502172352776.png)

基于数组可以直观看出数量、单位的含义：

- 数量：显示多少个内存单元的内容。
- 单位：单个内存单元的字节长度。

![image-20250502172537425](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502172537425.png)

⑧ 查看寄存器

```shell
info registers
```

![image-20250502173432090](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502173432090.png)

⑨ 反汇编

反汇编当前函数

```shell
# 完整指令disassemble
disas
```

![image-20250502173812077](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502173812077.png)

!!!note  
    更多命令可以在具体使用时再细细研究。

## 1.3 编译过程

使用 gcc 对`vim_cmd.c`文件进行编译时，并非直接生成可执行文件，中间还经历了预处理、编译和汇编等过程，同时gcc 也提供了生成中间文件的命令，可以帮助我们更好的了解编译过程。

![image-20250502233443183](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502233443183.png)

### 1.3.1 预处理

预处理过程主要进行 **头文件包含** 、 **宏定义替换** 处理，最后生成`.i`后缀的文件。

修改程序，添加一个宏定义并赋值给变量`a`，然后执行 gcc 命令生成预处理文件`vim_cmd.i`：

```shell
gcc vim_cmd.c -o vim_cmd.i -E
```

打开`vim_cmd.i`文件，可以看到调用的头文件被包含进来，并替换了宏常量和宏代码段。

!!!danger  
    预处理阶段不检查语法错误。

![image-20250502235629844](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250502235629844.png)

### 1.3.2 编译和汇编

编译阶段将预处理文件转化为汇编代码，生成`.s`后缀文件。汇编阶段将汇编代码转化为机器能执行的二进制机器码，生成`.o`后缀文件。

① 编译

执行如下命令，生成`vim_cmd.s`汇编文件，内容如下图所示。

```shell
gcc vim_cmd.c -o vim_cmd.s -S
```

![image-20250503004638946](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250503004638946.png)

② 汇编

执行如下命令，生成`vim_cmd.o`二进制文件，内容如下图所示。

```shell
gcc vim_cmd.c -o vim_cmd.o -c
```

![image-20250503130230169](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250503130230169.png)



### 1.3.3 链接

链接过程就是找到依赖的库文件，将目标文件链接为可执行程序。

库文件一般分静态库和动态库，静态库在编译链接时与可执行文件合为一体，动态库单独作为文件供可执行文件调用。

- **静态库** ：在链接时，把库文件的代码链接到可执行文件中，更占用内存资源，但执行速度快。
  - Windows系统后缀：`.lib`（Library）
  - Linux系统后缀：`.a`（Archive）
- **动态库/共享库** ：只有在用到的时候，才去链接库文件，可以被多个不同的程序调用，因此节省资源，但调用需要一定的装载时间。 
  - Windows系统后缀：`.dll`（Dynamic Link Library）
  - Linux系统后缀：`.so`（Shared Object）

① 编写源码

新建文件`function.c`、`function.h`、`main.c`，再`main.c`中调用`function.c`的函数。

![image-20250503214325409](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250503214325409.png)

② 编译和链接

编译生成二进制文件：

```shell
# 分步编译
gcc main.c -o main.o -c
gcc function.c -o function.o -c
```

链接：

```shell
# 链接文件
gcc function.o main.o -o main
```

编译链接一步到位：

```shell
gcc function.c main.c -o main_
```

③ 链接静态库

强制将`function.c`链接为静态库：

```shell
# 先将function.c编译为function.o
gcc function.c -o function.o -c
# 强制静态链接
gcc function.o main.c -o main_static -static
```

④ 动态链接库

强制将`function.c`链接为动态库：

```shell
# 生成共享库
gcc function.c -shared -fPIC -o libfunc.so
# 动态链接
gcc main.c -lfunc -L. -o main_share -Wl,-rpath='$ORIGIN'
```

!!!note  
    `-wl`用于给链接器 ld 传递参数，格式为`wl,<linker-option>`，`-rpath='$ORIGIN'`的功能是指定程序运行时搜索动态库的路径，`$ORIGIN` 表示可执行文件所在目录。

## 1.4 构建工具

在实际项目开发中，直接通过命令行逐一手动编译源代码文件的方式存在局限性，不仅需要记忆复杂的编译参数，更难以应对多文件协同编译、依赖关系管理和跨平台构建等工程化需求。为解决此问题，第一代 **构建系统** （如Make、Ninja）应运而生，通过声明式规则文件（Makefile/build.ninja）将编译逻辑抽象为可复用的任务流。

然而随着项目的复杂度增加，手动编写和维护构建规则文件也显得效率低下。因此催生出了第二代 **构建系统生成器** （如CMake、GN），通过简单的配置文件自动生成不同平台的构建文件，极大地简化了项目的编译和构建过程。

- **构建系统生成器**
  - Cmake：通过 `CMakeLists.txt` 生成 `Makefile` 或 `build.ninja`
  - GN：生成 `Ninja` 构建文件，专为大型项目设计
- **构建系统**
  - Make：根据 `Makefile` 规则调用编译器（如 GCC）完成代码构建
  - Ninja：替代 `make`，专注于快速执行构建步骤（需输入文件如 `build.ninja`）
- **编译器**
  - GCC：GNU 项目的一套编译工具
  - Clang：LLVM 项目的编译工具

![image-20250504135725498](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250504135725498.png)

### 1.4.1 准备环境

新建文件夹`2.make_cmake_gn_ninja`，相关文件按如下目录移植（均是编译章节用到的源文件）。

```shell
└── 2.make_cmake_gn_ninja
    ├── build			
    ├── include
    │   └── function.h
    ├── out			
    └── src
        ├── function.c
        └── main.c
```

### 1.4.1 Make

Make 是一个广泛使用的构建工具，与 GCC 一样来源于 GNU 项目，因此又称 GNU Make。Make 通过一个名为 makefile 的文件知道要如何编译你的项目，因此我们要在项目中编写一个 makefile 文件。

**Make 的功能**

- Make 允许用户在不了解具体构建细节的情况下编译和安装软件包——因为这些细节已记录在你提供的 `makefile` 中。
- Make 能 **自动确定需要更新的文件** ，若某个非源文件依赖于另一个非源文件，Make 会 **自动推断正确的更新顺序** 。
- 当修改部分源文件后运行 Make，它仅重新编译直接或间接依赖这些修改文件的非源文件，而非整个项目。
- Make 除构建软件包外，还可控制安装/卸载一个包。

!!!note  
    <kbd>源文件</kbd>指开发者直接编写和维护的文件，如`.c`、`.py`这类文件，而<kbd>非源文件</kbd>指的是通过工具生成的中间或最终文件，如`.o`、`.out`文件。

**makefile 的规则**

如下便是一个规则，而`makefile`就是有多个规则组成的。

```makefile
# target: 目标文件
# dependencies: 依赖文件
# commands: 要执行的命令
target: dependencies ...
		commands
		...
```

**makefile 简单应用**

在根目录下新建`makefile`文件，文件名称就是`makefile`，无后缀。

```makefile
# 定义工程目录
SRC_DIR := src 
INCLUDE_DIR := include
OBJ_DIR := build
BIN_DIR := out 

# 包含头文件路径，启动编译警告，生成调试信息
CFLAGS = -I$(INCLUDE_DIR) -Wall -g

# 可执行文件
TARGET = $(BIN_DIR)/main

# 获取src目录下所有.c文件列表
SOURCES = $(wildcard $(SRC_DIR)/*.c)
# 将.c路径替换为.o路径
OBJS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SOURCES))

# 默认目标
all : $(TARGET)

# 编写编译规则
$(TARGET) : $(OBJS)
    gcc $^ -o $@ 

$(OBJ_DIR)/%.o : $(SRC_DIR)/%.c
    gcc $< -o $@ -c $(CFLAGS)

# 清理规则
.PHONY: clean
clean :
    rm -rf $(OBJ_DIR)/*.o

```

根目录执行编译

```shell
make
```

运行可执行文件

![image-20250504183151049](https://tonmoon.obs.cn-east-3.myhuaweicloud.com/img/tonmoon/image-20250504183151049.png)

可以清理`build`目录下的`.o`文件

```shell
make clean
```

!!!note  
    网上有很多简单的`makefile`示例，就是基本的根据规则赋值`gcc`命令，我认为不符合实际项目需求，因此做了一个较综合的`makefile`示例，用到了变量、通配符、函数等功能。

**makefile 基础**

> 先较系统的介绍用到的`makefile`基础，然后再分析我们的`makefile`文件。

- 【变量】
  - `:=`：立即展开（在定义时求值）
  - `=`：延迟展开（在使用时求值）
  - `?=`：条件赋值（仅在未定义时赋值）

- 【自动变量】

  - `$@`：当前规则的目标文件
  - `$<`：当前规则的第一个依赖文件
  - `$^`：当前规则的所有依赖文件（去重）
  - `$*`：通配符 `%` 匹配的部分

- 【通配符】

  - `%`：匹配任意长度的字符串，可以配合函数和模式规则使用
  - `*`：

- 【函数】

  - `$(wildcard PATTERN)`：获取匹配 `PATTERN` 的文件列表，`PATTERN`是通配符表达式
  - `$(patsubst PATTERN,REPLACEMENT,TEXT)`：将 `TEXT` 中匹配 `PATTERN` 的部分替换为 `REPLACEMENT`
    - `PATTERN`: 匹配模式（必须包含 `%`）
    - `REPLACEMENT`: 替换模式（`%` 对应捕获的内容）
    - `TEXT`: 待处理的文本或变量
  - `$(shell COMMAND)`：执行 Shell 命令并返回结果

- 【条件判断】

  ```makefile
  ifeq (ARG1, ARG2)
      # 条件成立时执行
  else
      # 条件不成立时执行
  endif
  ```

**makefile 解析**

① 变量声明

按照`$(<变量>)`格式使用变量：

```makefile
# 定义工程目录
SRC_DIR := src 
INCLUDE_DIR := include
OBJ_DIR := build
BIN_DIR := out 

# 包含头文件路径，启动编译警告，生成调试信息
CFLAGS = -I$(INCLUDE_DIR) -Wall -g

# 可执行文件
TARGET = $(BIN_DIR)/main
```

② 函数

- `$(wildcard PATTERN)`函数获取`src`目录下的所以`.c`文件
- `$(patsubst PATTERN,REPLACEMENT,TEXT)`函数将`.c`路径替换为`.o`路径

```makefile
# 获取src目录下所有.c文件列表
SOURCES = $(wildcard $(SRC_DIR)/*.c)
# 将.c路径替换为.o路径
OBJS = $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SOURCES))
```

③ 默认目标

```makefile
# 默认目标
all : $(TARGET)
```

④ 链接规则

- `$(OBJS)`变量为所有`.o`依赖文件
- `$(TARGET)`变量为目标文件
- `$^`代指所有依赖文件，即`build\main.o`、`build\function.o`
- `$@` 代指目标文件，即`out\main`

```makefile
# 编写编译规则
$(TARGET) : $(OBJS)
    gcc $^ -o $@ 
```

⑤ 模式规则

- `%`通配符会动态生成目标和依赖关系
  - 当需要构建 `build/main.o` 时，Make 检查是否存在 `src/main.c`
  - `%` 捕获 main，`$<` 展开为 `src/main.c`，`$@` 展开为 `build/main.o`
- 此规则，逐个编译每个 `.c` 文件，生成对应的 `.o` 文件

```makefile
$(OBJ_DIR)/%.o : $(SRC_DIR)/%.c
    gcc $< -o $@ -c $(CFLAGS)
```

⑥ 清理规则

`.PHONY: clean`声明 `clean` 为伪目标，告诉 Make 不要检查 `clean` 文件是否存在，而是直接执行其命令。

```makefile
# 清理规则
.PHONY: clean
clean :
    rm -rf $(OBJ_DIR)/*.o
```

### 1.4.2 CMake



### 1.4.3 Ninja



### 1.4.4 GN





## 参考资料

[Linux环境下GCC基本使用详解（含实例）_linux gcc-CSDN博客](https://blog.csdn.net/qq_39872252/article/details/133309120)

[GCC编译器详解-CSDN博客](https://blog.csdn.net/qq_27870421/article/details/99682041?ops_request_misc=%7B%22request%5Fid%22%3A%22169569887416800192282218%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169569887416800192282218&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99682041-null-null.142^v94^insert_down1&utm_term=GCC使用&spm=1018.2226.3001.4187)